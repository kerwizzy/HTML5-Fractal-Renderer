<HEAD>
<SCRIPT>

//ctx.fillStyle="#FF0000";
//ctx.fillRect(20,20,150,100); 

var size = 1*.02; //How much is the numerical interval between pixels. I. E., size = 1 would mean that each pixel would roughly correspond to an integer. (Invervals of 1)
var work = {};
work.location = [0,0]; //Location of the CENTER of the view

function draw() {
work.ctx = myCanvas.getContext("2d");
work.imageData = work.ctx.createImageData(myCanvas.width,1) //Create an image for the row.


	
work.yI = 0;
work.interval = 16;
document.getElementById('locationDisplay').innerHTML = work.location.toString()+","+size.toString();


setTimeout(doWork,0);
}


function doWork () {
var interval = work.interval;

var cWidth = myCanvas.width;
var cHeight = myCanvas.height;
var viewWidth = work.cWidth*size; //The numerical width of the view.
var viewHeight = work.cHeight*size;
var locationX = work.location[0];
var locationY = work.location[1];
var ctx = work.ctx;
var yI = cHeight/2-work.yI;
	var d = work.imageData.data;
		for (var xI = 0; xI < cWidth; xI+=interval) {
			
			var currentPixelColor = "" //Create a hex RGB for the current pixel color. 

			currentPixelColor = renderPixel((((xI-cWidth/2)*size)+locationX),(((yI-cHeight/2)*size)+locationY)) //the percentage accross the view we are, times the actual size of the view, offset by the location from the orgin.
			//ctx.fillStyle = "#" + currentPixelColor;
			//ctx.fillRect(xI,yI,1,1); //Draw the pixel
			var p = xI*4;
			for (var i =0;i < interval;i++) {
				d[p++] = currentPixelColor&0xFF;
				d[p++] = currentPixelColor&0xFF;
				d[p++] = currentPixelColor&0xFF;
				d[p++] = 0xFF; //Set the alpha
			}
		}
		for (var i =0;i < interval;i++) {
			ctx.putImageData(work.imageData,0,yI+i);
		}
yI = cHeight/2+work.yI;
	
		for (var xI = 0; xI < cWidth; xI+=interval) {
			
			//var currentPixelColor = "" //Create a hex RGB for the current pixel color. 

			var currentPixelColor = renderPixel((((xI-cWidth/2)*size)+locationX),(((yI-cHeight/2)*size)+locationY)) //the percentage accross the view we are, times the actual size of the view, offset by the location from the orgin.
			//ctx.fillStyle = "#" + currentPixelColor;
			//ctx.fillRect(xI,yI,1,1); //Draw the pixel
			var p = xI*4;
			for (var i =0;i < interval;i++) {
				d[p++] = currentPixelColor&0xFF;
				d[p++] = currentPixelColor&0xFF;
				d[p++] = currentPixelColor&0xFF;
				d[p++] = 0xFF; //Set the alpha
			}

		}		
		for (var i =0;i < interval;i++) {
			ctx.putImageData(work.imageData,0,yI+i);
		}

work.yI += interval;
	if (work.yI < cHeight/2) {
	setTimeout(doWork,0);
	
	}
	else if (work.interval > 1) {
	work.yI = 0
	work.interval/=2;
	setTimeout(doWork,0)
	
	}


}


function renderPixel(real,imaginary) {

//var outColor = ((inSet(real,imaginary)&0xff)+0x1000).toString(16).substr(1);
var outColor = inSet(real,imaginary);
return outColor*30;


}


function inSet(real,imaginary) {
var zRe = 0;
var zIm = 0;


var out = 0

var iterations = 30000;

var i = 0;
for (i=0; i < iterations; i++) {
//z = i_a((i_t(z,z)),c);
var nzRe = (zRe*zRe+(-1*(zIm*zIm))) //Make a new variable to aviod reusing it in the next line.
zIm = (zRe*zIm+zIm*zRe)
zRe = nzRe

zRe += real;
zIm += imaginary;

//if (z2[0] != z[0] || z2[1] != z[1]) {
//	alert("I-72");
//}

if ((zRe*zRe)+(zIm*zIm) > 4) { //If it is outside the 4 unit circle...

out = 1; //Make it out of the set.
break; //stop it from running longer
}



}

return out*(256*i/iterations); //If it out = 0, then it wont matter. If out = 1, then it will return the number of interations it took to escape.
}






function i_a(add1,add2) { //Add two complex numbers
var out = [0,0];

out[0] = add1[0]+add2[0]
out[1] = add1[1]+add2[1]

return out;

}



function i_t(fact1,fact2) { //Multiply two complex numbers
var out = [0,0];

out[0] = fact1[0]*fact2[0]+(-1*(fact1[1]*fact2[1])) //Multiply the first part, and add in the second part times -1 (times negative one becuase of i^2)
out[1] = fact1[0]*fact2[1]+fact1[1]*fact2[0]

return out;

}


function i_abs(num) { //Take the absolute value of a complex number
var out = [0,0];

var outDist = 0;

outDist = Math.sqrt((num[0]*num[0])+(num[1]*num[1])); //Pythagorean theorem, distance from orgin.

out[0] = outDist;

return out;


return out;

}

function getCursorPosition(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    var x = event.clientX - rect.left;
    var y = event.clientY - rect.top;
	if (x/myCanvas.width < 0.1 || x/myCanvas.width > 0.9 || y/myCanvas.height < 0.1 || y/myCanvas.height > 0.9) {
	size = size*2 //Zoom out.
	}
	else {
    work.location[0] = ((x-myCanvas.width/2)*size+work.location[0]); 
	work.location[1] = ((y-myCanvas.height/2)*size+work.location[1]);
	size = size/2;
	}
	draw();
}


</SCRIPT>
</HEAD>
<BODY>
<H1> Fractal Renderer </H1>



<P>Location:<BR>
<PRE>
<DIV id=locationDisplay WIDTH=40>
</DIV>
</PRE>


<DIV>
<canvas id="myCanvas" width="1920" height="1000" style="border:0px">
Your browser does not support the HTML5 canvas tag.</canvas>
</DIV>
<SCRIPT>

var myCanvas = document.getElementById("myCanvas");
myCanvas.addEventListener("click",function(event) {getCursorPosition(myCanvas,event);});


draw() //Make it render when it starts.
</SCRIPT>

</BODY>